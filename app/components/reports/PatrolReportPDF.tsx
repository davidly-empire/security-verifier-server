"use client";

import React, { useEffect, useRef } from "react";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";

import { ScanLog } from "../../types/scanlog";
import { ROUND_TIMES } from "./roundtime";


// ================= Props =================
interface PatrolReportPDFProps {
  logs: ScanLog[];

  factoryCode: string;
  factoryName: string;
  factoryAddress: string;

  reportDate: string;
  generatedBy: string;
}


// ================= Component =================
const PatrolReportPDF: React.FC<PatrolReportPDFProps> = ({
  logs,
  factoryCode,
  factoryName,
  factoryAddress,
  reportDate,
  generatedBy,
}) => {

  // Prevent double generation (Strict Mode)
  const generatedRef = useRef(false);


  // ================= Auto Generate =================
  useEffect(() => {

    // Already generated
    if (generatedRef.current) return;

    // No data
    if (!logs || logs.length === 0) return;

    // No rounds
    if (!Object.keys(ROUND_TIMES).length) return;

    // ✅ WAIT FOR USER NAME
    if (!generatedBy || generatedBy.trim() === "") return;

    generatedRef.current = true;

    generatePDF();

  }, [
    logs,
    factoryCode,
    factoryName,
    factoryAddress,
    reportDate,
    generatedBy,
  ]);


  // ================= Status Normalizer =================
  const normalizeStatus = (status?: string | null): string => {

    if (!status) return "PROGRESS";

    const s = status.toLowerCase().trim();

    if (s === "success" || s === "completed" || s === "done") {
      return "SUCCESS";
    }

    if (s === "missed") {
      return "MISSED";
    }

    return "PROGRESS";
  };


  // ================= Border =================
  const drawBorder = (doc: jsPDF) => {

    const w = doc.internal.pageSize.getWidth();
    const h = doc.internal.pageSize.getHeight();

    doc.setDrawColor(0, 0, 180);
    doc.setLineWidth(0.8);

    doc.rect(8, 8, w - 16, h - 16);
  };


  // ================= Generate =================
  const generatePDF = () => {

    const doc = new jsPDF();

    const width = doc.internal.pageSize.getWidth();
    const height = doc.internal.pageSize.getHeight();


    // Font
    doc.setFont("times", "bold");


    // Border
    drawBorder(doc);


    // ================= Header =================

    doc.setTextColor(0, 0, 150);

    doc.setFontSize(20);
    doc.text("Security Patrol Report", width / 2, 20, { align: "center" });

    doc.setFontSize(16);
    doc.text(factoryName.toUpperCase(), width / 2, 30, {
      align: "center",
    });


    doc.setFont("times", "normal");
    doc.setFontSize(11);


    // Address
    doc.text(factoryAddress, width / 2, 38, {
      align: "center",
    });


    // Meta
    doc.setTextColor(40);

    doc.text(`Date : ${reportDate}`, 14, 50);

    // ✅ REAL USER NAME ALWAYS
    doc.text(`Generated By : ${generatedBy}`, 14, 56);

    doc.text(`Generated At : ${new Date().toLocaleString()}`, 14, 62);


    let y = 72;


    // ================= Group by Round =================
    const byRound: Record<number, ScanLog[]> = {};


    // Init rounds
    Object.keys(ROUND_TIMES).forEach((r) => {
      byRound[Number(r)] = [];
    });


    // Push logs
    logs.forEach((l) => {

      if (!byRound[l.round]) {
        byRound[l.round] = [];
      }

      byRound[l.round].push(l);
    });


    // ================= Render =================
    Object.keys(byRound)
      .map(Number)
      .sort((a, b) => a - b)
      .forEach((round) => {

        if (y > height - 50) {

          doc.addPage();
          drawBorder(doc);
          y = 20;
        }


        const time = ROUND_TIMES[round];


        // Round Header
        doc.setFont("times", "bold");
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 150);

        doc.text(
          `Round ${round} (${time?.start || "-"} - ${time?.end || "-"})`,
          14,
          y
        );

        y += 6;


        // ================= Rows =================
        let rows: any[] = [];


        // No scan
        if (byRound[round].length === 0) {

          rows.push(["-", "-", "-", "-", "-", "PROGRESS"]);

        } else {

          rows = byRound[round].map((l) => {

            const hasTime = !!l.scan_time;

            const status = hasTime
              ? normalizeStatus(l.status)
              : "PROGRESS";

            return [

              l.scan_time
                ? new Date(l.scan_time).toLocaleTimeString()
                : "-",

              l.guard_name || "-",

              l.qr_name || "-",

              l.lat || "-",

              l.lon || "-",

              status,
            ];
          });
        }


        // ================= Table =================
        autoTable(doc, {

          startY: y,

          head: [[
            "Time",
            "Guard",
            "QR Point",
            "Latitude",
            "Longitude",
            "Status",
          ]],

          body: rows,

          theme: "grid",

          styles: {
            font: "times",
            fontSize: 9,
            cellPadding: 3,
          },

          headStyles: {
            fillColor: [0, 70, 160],
            textColor: 255,
            fontStyle: "bold",
          },

          alternateRowStyles: {
            fillColor: [245, 248, 255],
          },


          // Status Colors
          didParseCell: (data) => {

            if (data.section === "body" && data.column.index === 5) {

              if (data.cell.raw === "SUCCESS") {
                data.cell.styles.textColor = [0, 150, 0];
                data.cell.styles.fontStyle = "bold";
              }

              if (data.cell.raw === "MISSED") {
                data.cell.styles.textColor = [200, 0, 0];
                data.cell.styles.fontStyle = "bold";
              }

              if (data.cell.raw === "PROGRESS") {
                data.cell.styles.textColor = [255, 140, 0];
                data.cell.styles.fontStyle = "bold";
              }
            }
          },


          didDrawPage: () => {
            drawBorder(doc);
          },

        });


        y = (doc as any).lastAutoTable.finalY + 12;

      });


    // ================= Footer =================
    // ================= Footer =================
const pages = doc.getNumberOfPages();

for (let i = 1; i <= pages; i++) {

  doc.setPage(i);

  doc.setFont("times", "normal");
  doc.setFontSize(9);
  doc.setTextColor(120);

  // Page Number (Center)
  doc.text(
    `Page ${i} of ${pages} | Security Verifier System`,
    width / 2,
    height - 12,
    { align: "center" }
  );

  // ✅ Generated By (Bottom Left)
  doc.text(
    `Generated By : ${generatedBy}`,
    14,
    height - 12
  );
}



    // ================= Save =================
    doc.save(`Patrol_Report_${factoryCode}_${reportDate}.pdf`);
  };


  return null;
};

export default PatrolReportPDF;
